const pluralize = require('pluralize');
const { objMerge, flatten, upcase } = require('@keystonejs/utils');
const { parseListAccess } = require('@keystonejs/access-control');
const { logger } = require('@keystonejs/logger');
const BaseList = require('./base');

const graphqlLogger = logger('graphql');

const { throwAccessDenied } = require('./graphqlErrors');

const preventInvalidUnderscorePrefix = str => str.replace(/^__/, '_');

const keyToLabel = str => {
  let label = str
    .replace(/([a-z])([A-Z])/g, '$1 $2')
    .split(/\s|_|\-/)
    .filter(i => i)
    .map(upcase)
    .join(' ');

  // Retain the leading underscore for auxiliary lists
  if (str[0] === '_') {
    label = `_${label}`;
  }
  return label;
};

const labelToPath = str =>
  str
    .split(' ')
    .join('-')
    .toLowerCase();

const labelToClass = str => str.replace(/\s+/g, '');

const opToType = { read: 'query', update: 'mutation' };

const getDefautlLabelResolver = labelField => item => {
  const value = item[labelField || 'name'];
  if (typeof value === 'number') {
    return value.toString();
  }
  return value || item.id;
};

module.exports = class Singleton extends BaseList {
  constructor(
    key,
    {
      fields,
      hooks = {},
      adminDoc,
      schemaDoc,
      labelResolver,
      labelField,
      access,
      adminConfig = {},
      itemQueryName,
      listQueryName,
      label,
      singular,
      plural,
      path,
      adapterConfig = {},
      queryLimits = {},
      cacheHint,
    },
    {
      getListByKey,
      queryHelper,
      adapter,
      defaultAccess,
      registerType,
      createAuxList,
      isAuxList,
      schemaNames,
    }
  ) {
    this.key = key;
    this._fields = fields;
    this.hooks = hooks;
    this.schemaDoc = schemaDoc;
    this.adminDoc = adminDoc;

    // Assuming the id column shouldn't be included in default columns or sort
    const nonIdFieldNames = Object.keys(fields).filter(k => k !== 'id');
    this.adminConfig = {
      defaultPageSize: 50,
      defaultColumns: nonIdFieldNames ? nonIdFieldNames.slice(0, 2).join(',') : 'id',
      defaultSort: nonIdFieldNames.length ? nonIdFieldNames[0] : '',
      maximumPageSize: 1000,
      ...adminConfig,
    };

    this.labelResolver = labelResolver || getDefautlLabelResolver(labelField);
    this.isAuxList = isAuxList;
    this.getListByKey = getListByKey;
    this.defaultAccess = defaultAccess;

    const _label = label || keyToLabel(key);
    const _singular = singular || pluralize.singular(_label);
    const _plural = plural || pluralize.plural(_label);

    if (_plural === _label) {
      throw new Error(
        `Unable to use ${_label} as a List name - it has an ambiguous plural (${_plural}). Please choose another name for your list.`
      );
    }

    this.adminUILabels = {
      // Fall back to the plural for the label if none was provided, not the autogenerated default from key
      label: label || _plural,
      singular: _singular,
      plural: _plural,
      path: path || labelToPath(_plural),
    };

    const _itemQueryName = itemQueryName || labelToClass(_singular);
    const _listQueryName = listQueryName || labelToClass(_plural);

    this.gqlNames = {
      outputTypeName: this.key,
      itemQueryName: _itemQueryName,
      listMetaName: preventInvalidUnderscorePrefix(`_${_listQueryName}Meta`),
      updateMutationName: `update${_itemQueryName}`,
      whereInputName: `${_itemQueryName}WhereInput`,
      whereUniqueInputName: `${_itemQueryName}WhereUniqueInput`,
      updateInputName: `${_itemQueryName}UpdateInput`,
      relateToOneInputName: `${_itemQueryName}RelateToOneInput`,
    };

    this.adapterName = adapter.name;
    this.adapter = adapter.newListAdapter(this.key, adapterConfig);
    this._schemaNames = schemaNames;

    this.access = parseListAccess({
      schemaNames: this._schemaNames,
      listKey: key,
      access,
      defaultAccess: this.defaultAccess.list,
    });

    this.queryLimits = {
      maxResults: Infinity,
      ...queryLimits,
    };
    if (this.queryLimits.maxResults < 1) {
      throw new Error(`List ${label}'s queryLimits.maxResults can't be < 1`);
    }

    if (!['object', 'function', 'undefined'].includes(typeof cacheHint)) {
      throw new Error(`List ${label}'s cacheHint must be an object or function`);
    }
    this.cacheHint = cacheHint;

    this.hooksActions = {
      /**
       * @param queryString String A graphQL query string
       * @param options.skipAccessControl Boolean By default access control _of
       * the user making the initial request_ is still tested. Disable all
       * Access Control checks with this flag
       * @param options.variables Object The variables passed to the graphql
       * query for the given queryString.
       *
       * @return Promise<Object> The graphql query response
       */
      query: queryHelper,
    };

    // Tell Keystone about all the types we've seen
    Object.values(fields).forEach(({ type }) => registerType(type));

    this.createAuxList = (auxKey, auxConfig) =>
      createAuxList(auxKey, {
        access: Object.entries(this.access).reduce(
          (acc, [schemaName, access]) => ({
            ...acc,
            [schemaName]: Object.entries(access).reduce(
              (acc, [op, rule]) => ({ ...acc, [op]: !!rule }), // Reduce the entries to truthy values
              {}
            ),
          }),
          {}
        ),
        ...auxConfig,
      });
  }

  getGqlTypes({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    const types = [];

    // We want to include `id` fields
    // If read is globally set to false, makes sense to never show it
    const readFields = this.getAllFieldsWithAccess({ schemaName, access: 'read' });
    if (schemaAccess.read || schemaAccess.update || schemaAccess.auth) {
      types.push(
        ...flatten(this.fields.map(field => field.getGqlAuxTypes({ schemaName }))),
        `
        """ ${this.schemaDoc || 'A keystone list'} """
        type ${this.gqlNames.outputTypeName} {
          """
          This virtual field will be resolved in one of the following ways (in this order):
           1. Execution of 'labelResolver' set on the ${this.key} List config, or
           2. As an alias to the field set on 'labelField' in the ${this.key} List config, or
           3. As an alias to a 'name' field on the ${this.key} List (if one exists), or
           4. As an alias to the 'id' field on the ${this.key} List.
          """
          _label_: String
          ${flatten(
            readFields.map(field =>
              field.schemaDoc
                ? `""" ${field.schemaDoc} """ ${field.gqlOutputFields({ schemaName })}`
                : field.gqlOutputFields({ schemaName })
            )
          ).join('\n')}
        }`,

        // https://github.com/opencrud/opencrud/blob/master/spec/2-relational/2-2-queries/2-2-3-filters.md#boolean-expressions
        `
        input ${this.gqlNames.whereInputName} {
          AND: [${this.gqlNames.whereInputName}]
          OR: [${this.gqlNames.whereInputName}]

          ${flatten(readFields.map(field => field.gqlQueryInputFields({ schemaName }))).join('\n')}
        }`,
        // TODO: Include other `unique` fields and allow filtering by them
        `
        input ${this.gqlNames.whereUniqueInputName} {
          id: ID!
        }`
      );
    }

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      types.push(`
        input ${this.gqlNames.updateInputName} {
          ${flatten(updateFields.map(field => field.gqlUpdateInputFields)).join('\n')}
        }
      `);
    }

    return types;
  }

  getGqlQueries({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    // All the auxiliary queries the fields want to add
    const queries = flatten(this.fields.map(field => field.getGqlAuxQueries()));

    // If `read` is either `true`, or a function (we don't care what the result
    // of the function is, that'll get executed at a later time)
    if (schemaAccess.read) {
      queries.push(
        `
        """ Search for the ${this.gqlNames.outputTypeName} item with the matching ID. """
        ${this.gqlNames.itemQueryName}: ${this.gqlNames.outputTypeName}`,

        `
        """ Retrieve the meta-data for the ${this.gqlNames.itemQueryName} list. """
        ${this.gqlNames.listMetaName}: _ListMeta`
      );
    }

    return queries;
  }

  gqlAuxFieldResolvers({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    if (schemaAccess.read || schemaAccess.update || schemaAccess.auth) {
      return objMerge(this.fields.map(field => field.gqlAuxFieldResolvers({ schemaName })));
    }
    return {};
  }

  getGqlMutations({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    const mutations = flatten(this.fields.map(field => field.getGqlAuxMutations()));

    // NOTE: We only check for truthy as it could be `true`, or a function (the
    // function is executed later in the resolver)

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      mutations.push(`
      """ Update a single ${this.gqlNames.outputTypeName} item by ID. """
        ${this.gqlNames.updateMutationName}(
          id: ID!
          data: ${this.gqlNames.updateInputName}
        ): ${this.gqlNames.outputTypeName}
      `);
    }

    return mutations;
  }

  async checkFieldAccess(operation, itemsToUpdate, context, { gqlName, ...extraInternalData }) {
    const restrictedFields = [];
    for (const { existingItem, id, data } of itemsToUpdate) {
      const fields = this.fields.filter(field => field.path in data);

      for (const field of fields) {
        const access = await context.getFieldAccessControlForUser(
          this.key,
          field.path,
          data,
          existingItem,
          operation,
          { gqlName, itemId: id, ...extraInternalData }
        );
        if (!access) {
          restrictedFields.push(field.path);
        }
      }
    }
    if (restrictedFields.length) {
      throwAccessDenied(opToType[operation], context, gqlName, extraInternalData, {
        restrictedFields,
      });
    }
  }

  async checkListAccess(context, originalInput, operation, { gqlName, ...extraInternalData }) {
    const access = await context.getListAccessControlForUser(this.key, originalInput, operation, {
      gqlName,
      ...extraInternalData,
    });
    if (!access) {
      graphqlLogger.debug(
        { operation, access, gqlName, ...extraInternalData },
        'Access statically or implicitly denied'
      );
      graphqlLogger.info({ operation, gqlName, ...extraInternalData }, 'Access Denied');
      // If the client handles errors correctly, it should be able to
      // receive partial data (for the fields the user has access to),
      // and then an `errors` array of AccessDeniedError's
      throwAccessDenied(opToType[operation], context, gqlName, extraInternalData);
    }
    return access;
  }

  async getAccessControlledItem(id, access, { context, operation, gqlName, info }) {
    const _throwAccessDenied = msg => {
      graphqlLogger.debug({ id, operation, access, gqlName }, msg);
      graphqlLogger.info({ id, operation, gqlName }, 'Access Denied');
      // If the client handles errors correctly, it should be able to
      // receive partial data (for the fields the user has access to),
      // and then an `errors` array of AccessDeniedError's
      throwAccessDenied(opToType[operation], context, gqlName, { itemId: id });
    };

    let item;
    if (
      (access.id && access.id !== id) ||
      (access.id_not && access.id_not === id) ||
      (access.id_in && !access.id_in.includes(id)) ||
      (access.id_not_in && access.id_not_in.includes(id))
    ) {
      // It's odd, but conceivable the access control specifies a single id
      // the user has access to. So we have to do a check here to see if the
      // ID they're requesting matches that ID.
      // Nice side-effect: We can throw without having to ever query the DB.
      _throwAccessDenied('Item excluded this id from filters');
    } else {
      // NOTE: The fields will be filtered by the ACL checking in gqlFieldResolvers()
      // We only want 1 item, don't make the DB do extra work
      // NOTE: Order in where: { ... } doesn't matter, if `access.id !== id`, it will
      // have been caught earlier, so this spread and overwrite can only
      // ever be additive or overwrite with the same value
      item = (await this._itemsQuery({ first: 1, where: { ...access, id } }, { context, info }))[0];
    }
    if (!item) {
      // Throwing an AccessDenied here if the item isn't found because we're
      // strict about accidentally leaking information (that the item doesn't
      // exist)
      // NOTE: There is a potential security risk here if we were to
      // further check the existence of an item with the given ID: It'd be
      // possible to figure out if records with particular IDs exist in
      // the DB even if the user doesn't have access (eg; check a bunch of
      // IDs, and the ones that return AccessDenied exist, and the ones
      // that return null do not exist). Similar to how S3 returns 403's
      // always instead of ever returning 404's.
      // Our version is to always throw if not found.
      _throwAccessDenied('Zero items found');
    }
    // Found the item, and it passed the filter test
    return item;
  }

  gqlQueryResolvers({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    let resolvers = {};

    // If set to false, we can confidently remove these resolvers entirely from
    // the graphql schema
    if (schemaAccess.read) {
      resolvers = {
        [this.gqlNames.listMetaName]: (_, args, context) => this.listMeta(context),

        [this.gqlNames.itemQueryName]: (_, args, context, info) =>
          this.itemQuery(args, context, this.gqlNames.itemQueryName, info),
      };
    }

    return resolvers;
  }

  listMeta(context) {
    return {
      name: this.key,
      // Return these as functions so they're lazily evaluated depending
      // on what the user requested
      // Evalutation takes place in ../Keystone/index.js
      // NOTE: These could return a Boolean or a JSON object (if using the
      // declarative syntax)
      getAccess: () => ({
        getRead: () => context.getListAccessControlForUser(this.key, undefined, 'read'),
        getUpdate: () => context.getListAccessControlForUser(this.key, undefined, 'update'),
        getAuth: () => context.getAuthAccessControlForUser(this.key),
      }),
      getSchema: () => {
        const queries = [this.gqlNames.itemQueryName];

        // NOTE: Other fields on this type are resolved in the main resolver in
        // ../Keystone/index.js
        return {
          type: this.gqlNames.outputTypeName,
          queries,
          key: this.key,
        };
      },
    };
  }

  gqlMutationResolvers({ schemaName }) {
    const schemaAccess = this.access[schemaName];
    const mutationResolvers = {};

    const updateFields = this.getFieldsWithAccess({ schemaName, access: 'update' });
    if (schemaAccess.update && updateFields.length) {
      mutationResolvers[this.gqlNames.updateMutationName] = (_, { id, data }, context) =>
        this.updateMutation(id, data, context);
    }

    return mutationResolvers;
  }
};
